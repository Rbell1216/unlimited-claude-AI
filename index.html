<!DOCTYPE html>
<html>
<head>
    <title>G4F Multiâ€‘Provider Tester</title>
    <style>
        body { font-family: sans-serif; max-width: 700px; margin: 2rem auto; padding: 0 1rem; }
        .form-group { margin-bottom: 1rem; }
        label { display: block; margin-bottom: 0.25rem; font-weight: bold; }
        select, input, button { width: 100%; padding: 0.5rem; box-sizing: border-box; }
        .row { display: flex; gap: 0.5rem; align-items: center; }
        .row select { flex: 1; }
        .row button { width: auto; }
        pre { background: #f4f4f4; padding: 1rem; border-radius: 4px; overflow-x: auto; margin-top: 1rem; }
        .note { background: #e8f4fd; padding: 0.5rem; border-radius: 4px; margin: 1rem 0; font-size: 0.9rem; }
    </style>
</head>
<body>
    <h1>G4F Multiâ€‘Provider Tester</h1>

    <div class="form-group">
        <label for="providerSelect">Select Provider:</label>
        <div class="row">
            <select id="providerSelect">
                <!-- These are the "none required" endpoints from your list -->
                <option value="https://g4f.space/api/groq">Groq (free)</option>
                <option value="https://g4f.space/api/ollama">Ollama (free)</option>
                <option value="https://g4f.space/api/pollinations" selected>Pollinations (free)</option>
                <option value="https://g4f.space/api/nvidia">Nvidia (free)</option>
                <option value="https://g4f.space/api/gemini">Gemini (free)</option>
                <option value="https://g4f.space/api/auto">Auto (free)</option>
                <option value="https://localhost:1337/v1">Localhost (selfâ€‘hosted)</option>
                <option value="custom">Custom URLâ€¦</option>
            </select>
            <button id="applyProviderBtn">Apply</button>
        </div>
    </div>

    <div class="form-group">
        <label for="baseUrl">Base URL (with /chat/completions appended):</label>
        <input type="url" id="baseUrl" value="https://g4f.space/api/pollinations" placeholder="e.g. https://g4f.space/api/groq">
    </div>

    <div class="form-group">
        <label for="modelSelect">Select Model:</label>
        <div class="row">
            <select id="modelSelect">
                <!-- Static fallback models â€“ will be replaced if fetch works -->
                <option value="gpt-4o">gpt-4o</option>
                <option value="gpt-4">gpt-4</option>
                <option value="gpt-3.5-turbo">gpt-3.5-turbo</option>
                <option value="claude-3-opus">claude-3-opus</option>
                <option value="claude-3-sonnet">claude-3-sonnet</option>
                <option value="llama-3-70b">llama-3-70b</option>
                <option value="gemini-pro">gemini-pro</option>
                <option value="deepseek-v3">deepseek-v3</option>
            </select>
            <button id="fetchModelsBtn">ðŸ”„ Refresh</button>
        </div>
    </div>

    <div class="form-group">
        <label for="message">Message:</label>
        <input type="text" id="message" value="Hello, how are you?" placeholder="Enter your message">
    </div>

    <button id="sendBtn">Send Message</button>

    <div class="note">
        <strong>Note:</strong> If a provider requires an API key, you'll need to add it via the <code>Authorization</code> header (not implemented in this demo). For the hosted instance (<code>https://g4f.space/v1</code>), get a free key from <a href="https://g4f.dev/api_key" target="_blank">g4f.dev/api_key</a>.
    </div>

    <pre id="output">Ready. Select a provider and click Send.</pre>

    <script type="module">
        import Client from 'https://g4f.dev/dist/js/client.js';

        // DOM elements
        const providerSelect = document.getElementById('providerSelect');
        const baseUrlInput = document.getElementById('baseUrl');
        const modelSelect = document.getElementById('modelSelect');
        const messageInput = document.getElementById('message');
        const output = document.getElementById('output');
        const applyProviderBtn = document.getElementById('applyProviderBtn');
        const fetchModelsBtn = document.getElementById('fetchModelsBtn');
        const sendBtn = document.getElementById('sendBtn');

        // Helper: fetch models from provider's /models endpoint
        async function fetchModels(baseUrl) {
            try {
                const cleanBase = baseUrl.replace(/\/$/, '');
                const modelsUrl = `${cleanBase}/models`;
                const response = await fetch(modelsUrl);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const data = await response.json();
                // Try to extract model list from common response shapes
                return data.data || data.models || data;
            } catch (err) {
                console.warn('Model fetch failed:', err);
                return null;
            }
        }

        // Update model dropdown with fetched models
        async function refreshModels() {
            const baseUrl = baseUrlInput.value.trim();
            if (!baseUrl) return;
            output.innerText = 'Fetching models...';
            const models = await fetchModels(baseUrl);
            if (models && Array.isArray(models) && models.length > 0) {
                modelSelect.innerHTML = '';
                models.forEach(item => {
                    const id = item.id || item;
                    const name = item.name || id;
                    const option = document.createElement('option');
                    option.value = id;
                    option.textContent = name;
                    modelSelect.appendChild(option);
                });
                output.innerText = `Loaded ${models.length} models.`;
            } else {
                output.innerText = 'Could not fetch models â€“ using static list.';
            }
        }

        // Apply selected provider: update baseUrl and refresh models
        function applyProvider() {
            const selected = providerSelect.value;
            if (selected === 'custom') {
                // Keep whatever is in the baseUrl input
                baseUrlInput.focus();
                output.innerText = 'Enter custom base URL manually.';
            } else {
                baseUrlInput.value = selected;
                refreshModels();
            }
        }

        // Send a test message
        async function sendMessage() {
            const baseUrl = baseUrlInput.value.trim();
            const model = modelSelect.value;
            const message = messageInput.value.trim() || 'Hello';
            if (!baseUrl || !model) {
                output.innerText = 'Please enter base URL and select a model.';
                return;
            }

            output.innerText = 'Sending...';
            try {
                const client = new Client({ baseUrl });
                const result = await client.chat.completions.create({
                    model: model,
                    messages: [{ role: 'user', content: message }]
                });
                output.innerText = JSON.stringify(result, null, 2);
            } catch (err) {
                output.innerText = `Error: ${err.message}`;
            }
        }

        // Event listeners
        applyProviderBtn.addEventListener('click', applyProvider);
        fetchModelsBtn.addEventListener('click', () => refreshModels());
        sendBtn.addEventListener('click', sendMessage);

        // Auto-refresh models when baseUrl changes (with debounce)
        let timeout;
        baseUrlInput.addEventListener('input', () => {
            clearTimeout(timeout);
            timeout = setTimeout(() => refreshModels(), 600);
        });

        // Initial load: fetch models for the default provider (pollinations)
        setTimeout(() => refreshModels(), 200);
    </script>
</body>
</html>
